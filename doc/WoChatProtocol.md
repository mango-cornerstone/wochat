# WoChat消息的加密规范

虽然普罗大众可能对加密和解密的技术了解不多，但是任何人对加密和解密的基本概念还是有正确的理解的，因为通讯安全是任何人的基本需求。微信的聊天数据很显然是不加密的，证据之一就是：如果你在微信中发表过激言论，很可能不久以后你就被腾讯公司封号，这表明有人在监控你的聊天信息。WoChat的理念就是采用世界上第一流的加密技术，确保每个人的通讯数据不被任何公司或者政府监控。本文档论述WoChat加密体系的设计规范，任何人都可以对本规范提出异议或者修改意见，让我们一起努力，设计出完美无缺的加密体系，保护每个人的通讯隐私权利。

## 加密技术快速入门

回归问题的本质，现在我们假设一个场景：张三想把一段明文(plain text)传递给他的好友李四。为了更准确地表达设计思想，我们采用类似数学记号的方式，把这段明文用P来表示。为了不让第三者看到传递的内容，张三使用密钥(key)把P变成了密文(cipher text)。类似的，我们用K表示密钥，用C表示加密后的密文。我们可以用如下的数学公式来表示P、K和C之间的关系：
```
C = f(P, K)
```

这个公式表明，密文C是某个函数f计算出来的。函数f被称为加密算法，该函数的输入参数有两个：明文P和密钥K。假设我们要发送的明文数据有n个字节，可以使用如下C语言变量来表示明文：

```c
unsinged char plaintext[MAX_LENGH];
unsigned int  plaintext_length;
```
其中plaintext是一个最大长度为MAX_LENGH的数组，plaintext_length表示plaintext实际的长度。

截止到目前为止，加密算法分为对称加密(symmetric encryption)算法和非对称加密(asymmetric encryption)算法两大体系。 两种加密体系的区别是非常容易理解的，下面我们分别论述它们的基本思想。

### 对称加密算法

对称加密的基本思想可以用“解铃还须系铃人”来概括，就是使用同一把密钥K对明文P进行加密和对密文C进行解密，用公式表示就是：
```
C = f(P, K)
P = g(C, K)
```
在上述两个公式中，f是加密算法，g是解密算法。最流行的对称加密算法是AES(Advanced Encryption Standard)加密算法和Chacha20加密算法。AES是块(block)加密算法，Chacha20是流(stream)加密算法。 块加密算法的基本思想是把明文P分成固定尺寸的块，然后对这个固定大小的块进行加密。譬如：AES算法把P分为16字节的块，如果P的长度不是16字节的倍数，则最后不足16字节的块需要按16字节补齐一些额外的无关字节。 流加密算法的基本思想是产生一个无穷无尽，很可能不重复的比特流(bit stream)，然后把这个比特流和明文P按每个字节进行异或(XOR: eXclusive OR)操作。异或操作是非常容易理解的，假设我们用^表示异或运算，异或操作一共有4个可能性：
```
0 ^ 0 = 0
0 ^ 1 = 1
1 ^ 0 = 1
1 ^ 1 = 0
```

下面是一个流加密的简单的例子，明文P是4个字节，流加密算法也产生了4个字节的密钥K，两者进行异或操作就得到了密文C。

```
K:  10110001,10111000,10101010,11010111
P:  11001010,10101011,01010101,01101010
C:  01111011,00010011,11111111,10111101
```

异或操作存在如下规律：

```
X ^ Y = Y ^ X
X ^ 0 = X
X ^ X = 0
C = P ^ K
P ^ K ^ K = P
P = C ^ K
```

第一个公式表明异或操作满足交换律。第二个公式表明0和任何数据异或，依然是该数据本身。第三个公式表明两次和同一个数据进行异或，就相当于啥也没干。第四个公式表明密文C是由明文P和于P长度相同的密钥流K异或得到的。第五和第六个公式揭示了解密的过程，就是密文再次和同样的K异或就得到了明文。流加密算法的一个特征是：密文C的长度和明文P的长度是一样的，这就给攻击者提供了明文长度的敏感信息。 在后面的设计中，如果P小于252个字节，我们就把P作为一个整体嵌入到一个252字节的随机数据包中，让攻击者无法知道明文的长度。

如果AES算法使用的密钥K是32字节，我们称这个算法为AES256，它是目前已知的最安全的对称加密算法之一。Chacha20的密钥也是32字节。 WoChat采用AES256和Chacha20(32字节的密钥)作为两种对称加密的算法。

发送者用密钥K对P进行加密后形成密文C，他必然要把K和C都发送给接收者。 接收者光有C，没有K，当然无法完成解密的工作。对称加密算法最大的挑战是如何把密钥K安全可靠地传递给接收者。我们假设在发送者和接收者之间的通讯渠道是非常恶劣的，两者之间发送的任何信息都被第三者轻易地捕获到。你当然可以用另外一个密钥K1加密K，但是你依然存在如何把K1安全可靠地传递给对方的问题，所以光依靠对称加密算法本身是无法解决这个问题的。这个挑战的答案就在于下面我们要介绍的非对称加密算法体系中。

### 非对称加密算法

非对称加密算法和对称加密算法的最大不同点在于，在非对称加密算法中，发送者和接收者分别有一个密钥对(key pair)，就是两把密钥：一把是私钥sK(secret Key)，一把是公钥pK(public Key)。 私钥，顾名思义，就是私密的，不能够被别人掌握的密钥。所以私钥和对称加密算法中的密钥一样，必须被妥善地保存，它的泄露就意味着整个加密过程和加密体系被破解。公钥，顾名思义，就是公开的，可以被任何人知道的密钥。既然公钥是需要被公开的，所以它不应该被称为“密”钥。公钥本质上就是私钥的唯一性标识Id(identifier)，它唯一性地确定一个私钥的拥有者。所以，在WoChat的账号体系中，每一个账号就是一个公钥。用户名仅仅是公钥的一个昵称，供人类来区分不同的公钥而已。起到加密和解密实质作用的是公钥，而不是用户名，这一点需要读者理解清楚。

如果你知道了某个人的公钥pK，你无法推导出pK对应的私钥sK，这是非对称加密算法设计时就充分考虑过的问题。所以任何人的公钥pK都可以放心大胆地被传播，完全不需要担心别人利用自己的公钥pK能够推算出自己小心翼翼守护的私钥sK。 

假设接收者的私钥是sK1，公钥是pK1，接收者的私钥是sK2，公钥是pK2，则下面的公式成立：
```
C = f(pK2, P)
P = g(sK2, C)

C = f(pK1, P)
P = g(sK1, C)
```
上述公式表明：发送者使用接收者的公钥pK2对明文P进行加密，接收者收到密文C后使用自己的私钥sK2可以对明文进行解密。因为pK2是任何人都知道的，所以任何人都可以使用pK2来加密消息，但只有sK2的持有者才能够解密和阅读被加密的信息。 类似的，接收者可以用发送者的公钥pK1来加密数据，发送者使用自己的私钥sK1来解密，实现双向通讯。

非对称加密拥有和对称加密截然不同的密钥设计，一切看起来都这么完美，岁月静好。但非对称密钥依然无法解决一个问题：如何证明某个公钥pK是属于某个人的？这是一个超出加密解密知识范围的问题，但却是我们需要解决的一个实际问题。 一种解决思路是找第三方权威机构做背书和证明，证明某个公钥pK是属于某个人的。这就引入更复杂的CA(certificate authority)的系统。 

WoChat并不会引入权威的第三方权威机构做背书，而是采用一种简便可行的方案。WoChat使用的非对称加密算法的公钥是33个字节，譬如下面就是一个合法的公钥：

```
0288D216B2CEB02171FF4FD3392C2A1AC388F41FBD8392A719F690829F23BCA8E5
```

因为这个字符串很短，才66个字符，所以朗读一遍可以在一分钟之内搞定。你拿到某个号称是某个人的公钥后，你可以打电话给他，让他在电话中大声朗读自己的公钥。他一边朗读，你一边核对，不到一袋烟的功夫可以完成验证工作。 当你验证某个公钥的的确确是属于某个你熟知的朋友以后，你就可以放心大胆地使用这把公钥加密数据发送给他。因为你可以百分百地确定：在这个世界上只有你的这位朋友可以读取你发送的加密数据，拜登爷爷和普京大叔想偷窥都不可能做到。但是在量子计算机大规模投入实用以后，我们不能做到百分百有信心。不过如果此时此刻你处于量子计算机大规模普及的时代，你很有可能看不到这篇文档了 :-)。

非对称加密的常见算法有RSA和椭圆曲线ECC(Ellipse Curve Cryptography)加密算法。WoChat采用来自比特币内核的非对称加密算法secp256k1，它属于ECC算法家族中的一种。比特币的成功证明了这种算法的可靠性，所以我们可以放心大胆地使用在WoChat中。它的源码可以在比特币内核源码中找到( https://github.com/bitcoin/bitcoin/tree/master/src/secp256k1 )。 这是一个单独的模块，不依赖比特币内核的其它代码，所以你可以抠出来放在自己的应用中使用。

在secp256k1算法中，私钥sK是一个32字节的随机数，可以用任何你信任的随机数产生器(random number generator)产生出来。一旦sK产生出来后，公钥pK可以由sK轻松计算出来，反过来则不可能由pK计算出sK。公钥pK的长度是65个字节，但是可以压缩。压缩后的公钥是33个字节，实际上是257个比特，包含256比特的真正数据和一个标记比特位。在椭圆曲线算法中，公钥和私钥实际上是二维笛卡尔坐标中的某个点的位置(x,y)。 椭圆曲线是上下对称的，如果某个点(x,y)在该椭圆曲线上，则(x, -y)也在该椭圆曲线上。这个标记比特位就是表明最终的点是(x,y)还是(x,-y)，具体的细节我们就不深究了。所以压缩版的pK的第一个字节肯定是02或者03，不可能是别的值。 重复一下：WoChat使用的非对称加密算法secp256k1的私钥是32字节，公钥是33字节。

现在我们来学习一下非对称密钥如何解决前文中对称密钥传递困难的问题。在secp256k1算法中，存在一个规律，用公式表示如下：

```
Kp = f(sK1, pK2) = f(sK2, pK1)
```

在上述公式中，Kp是一个32字节的密钥，它可以由发送者的私钥sK1和接收者的公钥pK2计算出来，也可以由接收者的私钥sK2和发送者的公钥pK1计算出来。所以Kp可以理解为是发送者和接收者都知道的一个巨大的数字，但是他们之间心有灵犀一点通，无需传递Kp。因为Kp不会在发送者和接收者之间传递，所以任何第三方是无法知道Kp的。这一点非常非常重要，这是WoChat的安全体系的基石。非对称加密算法就是利用这一点，巧妙而完美地解决了对称加密算法无法解决的密钥传递问题，解决之道就是：密钥无需传递！

一旦发送者和接收者被确定后，他们之间的Kp是固定不变的，因为sK1和pK2，或者sK2和pK2是确定不变的，所以我们把Kp称为两者之间通讯过程的主密钥(primary key)。很显然，Kp的安全性由sK1和sK2来保证：一旦sK1或者sK2被泄露，则Kp就泄露了。 保护私钥sK是整个安全体系唯一需要特别小心的地方。反过来说：只要私钥sK没有泄露，整个安全体系在理论上是没有任何漏洞的。 在实践中，我们使用口令来保护私钥。你输入一个任意长度的口令，该口令被SHA256算法哈希成32字节的哈希值，然后我们用这个哈希值和AES256算法对sK进行加解密。口令和密钥是两个完全不同的概念，口令的作用仅仅是用来保护私钥sK。真正加密和解密是sK和pK的游戏。 在WoChat的账号体系中，口令的长度不限，可以任意长。当然越长的口令越不容易被破解。

如果某个用户的sK被泄露，只影响他和别人之间的通讯安全，不会影响别人之间的通讯安全。 当你的私钥sK被泄露以后，你可以重新产生一把私钥，因为它无非就是一个32字节的随机数嘛。 当你产生新的私钥sK后，公钥pK也随之发生改变，你依然需要向别人证明pK是属于你的。最简单的办法就是打电话通知朋友，然后在电话中核对你的公钥。

非对称加密算法虽然有很多的优点，但是它的加密和解密速度慢，只适合加密和解密少量数据，譬如加密32字节的时间是可以忍受的。 我们可以把对称加密和非对称加密算法的优点结合起来，形成优势互补的方案：大批量真正的数据依然使用对称加密算法进行加密，所使用的密钥K可以由非对称加密算法加密。所以在WoChat的加密体系中，真正干苦活累活的是对称加密算法AES256或者Chacha20，牵牛鼻子的是非对称加密算法secp256k1。


## WoChat加密的设计思想概述


真正的数据采用流加密算法。流加密算法的一个特征就是明文和密文的长度相等。因为我们在聊天过程中大部分时间输入的文字长度都很短，譬如：你好啊，非常棒！赞一个！ 我要下线了，你多保重等等。 为了不让攻击者获得短明文的长度信息，我们做如下设计：如果n小于252个字节，我们就构造一个252字节的随机数据包，把明文数据作为一个整体，嵌入到这个随机数据包中。明文在这个数据包中的存放是连续的，所以我们需要两个变量来标记明文在这252字节中的位置：长度n和偏移量offset。n的取值范围是1到251。offset的取值范围是0到252 - n。 为什么选择252呢？目的是为了让整体的长度凑成3的倍数，经过base64编码后就不存在补齐的等号(=)了，因为base64的基本思想是把3个字节的原文变成4个字节的编码。一个字节是8比特，3个字节是24比特，24 = 4 X 6，所以可以被分为4个6比特，6比特可以由64个字符组成，包括0-9, A-Z, a-z, +和/，共计64个普通可打印的字符，这是base64的基本设计思想。

如果n大于等于252个字节，则不需要上面的凑齐操作，所以offset恒定为0。

经过上面处理的明文，如何进行加密呢？ 我们会产生一个32字节的随机数，作为加密所使用密钥Ks，使用流加密算法Chacha20对真正的数据进行加密。Ks被称为会话密钥(session key)。所谓会话(session)密钥，指的是每次(session)加密操作都选择不同的密钥，一次一密。很显然，Ks是需要随着加密后的密文一起发送给接收者的。我们不可能把Ks的明文发送给接收者，否则任何人都可以解密了，所以我们必须要对Ks进行加密。对Ks加密所使用的算法是AES256，所使用的密钥是主密钥Kp，32个字节。Kp是由发送方的私钥sK1和接收方的公钥pK2计算出来的。同时，接收方的私钥sK2和发送方的公钥pK1也可以计算出Kp，所以Kp不需要传递，这是WoChat整个安全体系的根本保证。

总结一下：真正的数据使用Chacha20流加密技术，一次一密，所使用的密钥Ks是32字节的随机数，Ks被称为会话密钥。 Ks本身由AES256算法进行加密，所使用的密钥Kp是利用椭圆曲线的公钥和私钥计算出来的。概括成两句话，那就是：主密钥Kp加密会话密钥Ks，Ks加密真正的数据。每次加密，Ks都不一样，而Kp是固定的。

```
Kp --(AES256)--> Ks --(Chacha20)--> plain text
```

再次强调一下：整个安全体系的基础在于发送方的私钥sK1和接收者的私钥sK2不被泄露。只要这个前提条件被满足，整个安全加密的体系是没有任何明显的漏洞的。

以上就是WoChat加密规范的基本思想。 在理解了基本思想后，我们来看看WoChat加密消息包的具体格式。

## 加密格式的具体规范

目前WoChat消息包分为三种类型，包含真正数据的普通消息包、收到消息的确认消息包和要求撤销消息的请求消息包。以后随着开发的功能越来越多，可能会增加新的消息包类型，但是基本的格式会保持不变。

下面依次论述这三种不同类型的消息包。

### 包含真正数据的普通消息包

在WoChat通讯过程中，这种消息包属于最常见的类型，因为其中包含通讯双方真正想交流的数据。这些数据可以是文本，也可以是图片、视频等二进制信息。 这种消息包的规范可以用下图表示。

![](x0001.svg) 

如图所示，整个消息包分为三部分，下面介绍每一个部分的内容。

#### 消息包的第一部分

消息包的第一部分就是头66个字节。它记录着发送者的公钥的字符串。因为椭圆曲线公钥是33个字节，变成人可读的字符串就是66个字节，譬如一个字节0xA3变成了'A3'，这是两个字节。所以33个字节的原始公钥变成人可读的形式，就是66个字节。 接收者的公钥就是接收到数据包的MQTT的主题(topic)，所以消息包中不包含接收者的公钥，只包含发送者的公钥。虽然任何人都可以在接收者的公钥的topic上接收消息包，但是只有拥有接收者公钥对应的私钥的人才可以解开消息包，所以不怕别人偷听。 这部分的数据没有采用base64编码，目的是为了方便程序开发过程中的调试。

#### 消息包的第二部分
就是消息包的第67个字符，它固定是竖线符号|，表示和后面的数据包的分隔符。从第68个字节开始到最后，都是base64编码的数据。

#### 消息包的第三部分

从第68个字节开始到消息包的最后，都是base64编码的数据。这些数据是消息包的第三部分。

base64编码的数据经过base64解码后，分为五个域。头四个域的长度是固定的，分别是32字节，4字节，4字节和32字节。第五个域保存真正的数据，它的长度n是可变的，最小是252个字节。MQTT消息包的最大长度是256MB，所以n的最大值大约是256MB，扣除在它前面的字节的开销。

除了第一个域以外，后面四个域的数据都是经过Chacha20流加密算法加密的。所以你必须先用Chacha20进行解密，才能够解读里面的内容。解密的密钥Ks是32个字节，保存在第一个域中。Ks又是被主密钥K使用AES256加密算法加密的。K是由发送方的私钥sK1和接受方的公钥pK2计算出来的。

这五个域的含义分别论述如下。

##### 第一个域

第一个域是头32个字节，保存会话密钥Ks。当然Ks是经过主密钥Kp使用AES256加密算法加密的。 从第二个域开始，一直到消息包的最后一个字节，都是使用Ks作为密钥，使用Chacha20流加密算法进行加密的。

##### 第二个域
第二个域是第一个域随后紧挨的4个字节。它记录后面真正数据包的长度。该域按照小端格式(little-endian)存放。譬如长度是1193046个字节，就是十六进制的0x123456。则这个域的四个字节中，第一个字节保存56，第二个字节保存34，第三个字节保存12，第四个字节保存0。

##### 第三个域
第三个域是第二个域随后紧挨的4个字节。这四个字节目前只使用了头3个字节，最后一个字节保留供未来使用。 这个域的第一个字节，表示加密规范的版本，目前恒定为1。 第二个字节表示后面的数据的类型。T表示文本类型，不是T则表示二进制类型，譬如图片或者视频等信息。这个字节的取值可以是：
- T 表示文本
- G 表示GIF格式的图片
- P 表示PNG格式的图片
- J 表示Jpeg格式的图片
- B 表示BMP格式的图片
- M 表示MP4的视频
- m 表示mp3格式的音频
- S 表示SWF格式专用的教育视频格式

这个列表还可以继续扩充。这部分未来会进一步规范。

第三个字节表示真正的数据在后面n个字节中的偏移量。如果真正的数据大于等于252，则这个字节的值恒定为0。 如果真正的数据长度n小于252，则这个字节的取值范围是0到252 - n 。

第四个字节保留未用，供将来使用。

##### 第四个域
第四个域是32字节，表示真正数据的SHA256的哈希值。 如果明文的长度是52个字节，它保存在252字节的随机数据包中，偏移量的取值范围是0到200。 这该域计算的是52个字节的SHA256哈希值，不包括那些随机填充的数据。

##### 第五个域

第五个域就是真正的数据了，它的长度为n。前面已经讲过了，如果发送的消息长度小于252字节，则真正的数据包包含在一个252字节的随机数据包中。所以n的最小值为252。 由于汉字在UTF16下通常是2个字节，在UTF8下是3个字节，为了节省流量，真正的文本数据采用UTF16编码。对于图片视频等二进制文件，就不存在编码的问题了，该是啥就是啥。

##### 一点优化

第二个域和第三个域共计8个字节。里面的明文数据，除了最后两个字节以外，其余六字节的明文，攻击者是可以知道的。譬如，第三个域的第一个字节表示版本信息，目前它的值固定是1。如果发送的是文字，则第二个字节是'T'。第二个域的四字节的长度信息也很容易知道，因为攻击者可以自行构造指定长度的消息包。所以攻击者会把这6字节的密文和明文进行异或(XOR)，就可以获得加密这6字节的流加密的比特流。如果攻击者获得了Chacha20输出的密钥流的最初的48比特的密钥，是否会对他攻击Chacha20算法和密钥起到某种提示作用呢？我目前还不清楚这个问题，但不让攻击者知道最初的48比特密钥总比让他知道要好，这一点是毫无疑问的。

为了不让攻击者获得开始的48比特的密钥（可能这个信息对整体的共计也没啥帮助，不过为了小心起见），这里做了一个小优化。我们把第一个域的32字节，即Ks的明文，计算出一个CRC32C的值，4个字节。然后利用这四个字节和第二、三个域的八个字节进行异或，这样的操作可以防止攻击者获得Chacha20输出的头48比特的密钥。 这样的设计可能会堵住一些潜在的漏洞，谁知道呢？。有一点确凿无疑：有这个设计比没有强，至少不差，所以我们就加上这道保险栓。 


### 确认消息包

当接收方收到普通消息包后，会对消息包进行解密和验证。验证的工作就是比对实际内容和消息包头的SHA256值是否相等，这个值是32个字节。 每一个消息都有一个独一无二的SHA256值。 当校验无误后，接收方会向发送方发送一个确认消息包。这种消息包的格式可以用下图表示：

![](x0002.svg) 

这种消息包格式很简单，共计131个字节。头66个字节是接收者的公钥，中间一个加号，再后面64个字节表示解密后的消息的SHA256值。 发送者拿到这个消息包后，和自己发送的消息的SHA256进行校验后，就可以知道接收者的的确确收到了自己的消息，他可以在界面上做一些标记，譬如在消息的右上角加上一个勾号，知道对方的的确确收到了自己的消息。

### 请求消息包

发送者发送消息后，在一定时间内，譬如30秒之内，突然后悔了，想撤回自己发送的消息，就向接收者发送如下格式的消息包。但是接收者是否接受撤回，由接收者说了算。譬如接收者编译WoChat源码时禁止撤回消息功能。 所以这个消息包仅供接收者参考，是否撤回的权力在接收者。

![](x0003.svg) 

这种消息包格式很简单，共计131个字节。头66个字节是发送者的公钥，中间一个减号，再后面64个字节表示解密后的消息的SHA256值。 接收者拿到这个消息包后，和自己接受到的消息解密后的SHA256进行校验后，就可以知道发送者要求撤销哪个消息包。 是否撤销的动作由接收者说了算。


## 意见反馈

本文档最后修订日期是2024年2月19日。有任何问题或者建议，请发信到wochatdb@gmail.com




